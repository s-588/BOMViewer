// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package sqlite

import (
	"context"
	"database/sql"
)

const searchAll = `-- name: SearchAll :many
SELECT
    f.type,
    f.ref_id,
    COALESCE(
        CASE
            WHEN f.type = 'product' THEN p.name
            WHEN f.type = 'material' THEN mn.name
        END,
        ''
    ) AS display_name,
    f.text,
    f.score
FROM
    fts f
    LEFT JOIN products p ON f.type = 'product'
    AND f.ref_id = p.product_id
    LEFT JOIN material_names mn ON f.type = 'material'
    AND f.ref_id = mn.material_id
    AND mn.is_primary = 1
WHERE
    f.text MATCH ?
ORDER BY
    f.score ASC
LIMIT
    ?
`

type SearchAllParams struct {
	Text  string
	Limit int64
}

type SearchAllRow struct {
	Type        string
	RefID       string
	DisplayName interface{}
	Text        string
	Score       string
}

func (q *Queries) SearchAll(ctx context.Context, arg SearchAllParams) ([]SearchAllRow, error) {
	rows, err := q.db.QueryContext(ctx, searchAll, arg.Text, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAllRow
	for rows.Next() {
		var i SearchAllRow
		if err := rows.Scan(
			&i.Type,
			&i.RefID,
			&i.DisplayName,
			&i.Text,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMaterials = `-- name: SearchMaterials :many
SELECT
    f.ref_id,
    mn.name AS display_name,
    f.text,
    u.unit,
    COALESCE(pm.quantity, pm.quantity_text) AS quantity,
    score
FROM fts f
LEFT JOIN materials m
    ON f.ref_id = m.material_id
LEFT JOIN material_names mn
    ON f.ref_id = mn.material_id AND mn.is_primary = 1
LEFT JOIN product_materials pm
    ON m.material_id = pm.material_id
INNER JOIN unit_types u
    ON m.unit_id = u.unit_id
LEFT JOIN json_each(json(sqlc.arg(units))) je
    ON m.unit_id = je.value
WHERE
    f.text MATCH ?1
    AND (
        json_array_length(json(?2)) = 0
        OR je.value IS NOT NULL
    )
ORDER BY score ASC
LIMIT ?3
`

type SearchMaterialsParams struct {
	Query string
	Units interface{}
	Limit int64
}

type SearchMaterialsRow struct {
	RefID       string
	DisplayName sql.NullString
	Text        string
	Unit        string
	Quantity    interface{}
	Score       string
}

func (q *Queries) SearchMaterials(ctx context.Context, arg SearchMaterialsParams) ([]SearchMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMaterials, arg.Query, arg.Units, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMaterialsRow
	for rows.Next() {
		var i SearchMaterialsRow
		if err := rows.Scan(
			&i.RefID,
			&i.DisplayName,
			&i.Text,
			&i.Unit,
			&i.Quantity,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT
    f.ref_id,
    p.name AS display_name,
    f.text,
    f.score
FROM
    fts f
    LEFT JOIN products p ON f.ref_id = p.product_id
WHERE
    f.text MATCH ?
    AND f.type = 'product'
ORDER BY
    f.score ASC
LIMIT
    ?
`

type SearchProductsParams struct {
	Text  string
	Limit int64
}

type SearchProductsRow struct {
	RefID       string
	DisplayName sql.NullString
	Text        string
	Score       string
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts, arg.Text, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsRow
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.RefID,
			&i.DisplayName,
			&i.Text,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
