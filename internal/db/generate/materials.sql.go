// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: materials.sql

package sqlite

import (
	"context"
	"database/sql"
)

const addMaterialName = `-- name: AddMaterialName :one
INSERT INTO
    material_names (material_id, name, is_primary)
VALUES
    (?, ?, ?) RETURNING name_id, material_id, name, is_primary
`

type AddMaterialNameParams struct {
	MaterialID int64
	Name       string
	IsPrimary  bool
}

func (q *Queries) AddMaterialName(ctx context.Context, arg AddMaterialNameParams) (MaterialName, error) {
	row := q.db.QueryRowContext(ctx, addMaterialName, arg.MaterialID, arg.Name, arg.IsPrimary)
	var i MaterialName
	err := row.Scan(
		&i.NameID,
		&i.MaterialID,
		&i.Name,
		&i.IsPrimary,
	)
	return i, err
}

const deleteAllMaterialNames = `-- name: DeleteAllMaterialNames :exec
DELETE FROM material_names
WHERE
    material_id = ?
`

func (q *Queries) DeleteAllMaterialNames(ctx context.Context, materialID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllMaterialNames, materialID)
	return err
}

const deleteMaterial = `-- name: DeleteMaterial :exec
DELETE FROM materials
WHERE
    material_id = ?
`

func (q *Queries) DeleteMaterial(ctx context.Context, materialID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMaterial, materialID)
	return err
}

const getAllMaterials = `-- name: GetAllMaterials :many
SELECT 
    m.material_id,
    m.unit_id,
    m.description,
    ut.unit,
    mn.name AS primary_name,
    pm.quantity,
    pm.quantity_text,
    p.product_id,
    p.name AS product_name
FROM 
    materials m
    INNER JOIN unit_types ut ON m.unit_id = ut.unit_id
    INNER JOIN material_names mn ON m.material_id = mn.material_id AND mn.is_primary = TRUE
    LEFT JOIN product_materials pm ON m.material_id = pm.material_id
    LEFT JOIN products p ON pm.product_id = p.product_id
ORDER BY 
    m.material_id
`

type GetAllMaterialsRow struct {
	MaterialID   int64
	UnitID       int64
	Description  sql.NullString
	Unit         string
	PrimaryName  string
	Quantity     interface{}
	QuantityText sql.NullString
	ProductID    sql.NullInt64
	ProductName  sql.NullString
}

func (q *Queries) GetAllMaterials(ctx context.Context) ([]GetAllMaterialsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMaterialsRow
	for rows.Next() {
		var i GetAllMaterialsRow
		if err := rows.Scan(
			&i.MaterialID,
			&i.UnitID,
			&i.Description,
			&i.Unit,
			&i.PrimaryName,
			&i.Quantity,
			&i.QuantityText,
			&i.ProductID,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialByID = `-- name: GetMaterialByID :one
SELECT
    materials.material_id, materials.unit_id, materials.description,
    unit_types.unit AS unit,
    product_materials.quantity AS quantity
FROM
    materials
    inner join unit_types on materials.unit_id = unit_types.unit_id
    inner join product_materials on product_materials.material_id = materials.material_id
WHERE
    materials.material_id = ?
`

type GetMaterialByIDRow struct {
	MaterialID  int64
	UnitID      int64
	Description sql.NullString
	Unit        string
	Quantity    interface{}
}

func (q *Queries) GetMaterialByID(ctx context.Context, materialID int64) (GetMaterialByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getMaterialByID, materialID)
	var i GetMaterialByIDRow
	err := row.Scan(
		&i.MaterialID,
		&i.UnitID,
		&i.Description,
		&i.Unit,
		&i.Quantity,
	)
	return i, err
}

const getMaterialByName = `-- name: GetMaterialByName :one
select
    m.material_id, m.unit_id, m.description,
    pm.quantity AS quantity,
    pm.quantity_text AS quantity_text,
    mn.name AS material_name,
    ut.unit AS unit
from
    materials m
    inner join product_materials pm on m.material_id = pm.material_id
    inner join material_names mn on m.material_id = mn.material_id
    inner join unit_types ut on ut.unit_id = m.unit_id
where
    name = ?
`

type GetMaterialByNameRow struct {
	MaterialID   int64
	UnitID       int64
	Description  sql.NullString
	Quantity     interface{}
	QuantityText sql.NullString
	MaterialName string
	Unit         string
}

func (q *Queries) GetMaterialByName(ctx context.Context, name string) (GetMaterialByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getMaterialByName, name)
	var i GetMaterialByNameRow
	err := row.Scan(
		&i.MaterialID,
		&i.UnitID,
		&i.Description,
		&i.Quantity,
		&i.QuantityText,
		&i.MaterialName,
		&i.Unit,
	)
	return i, err
}

const getMaterialNames = `-- name: GetMaterialNames :many
select
    name_id, material_id, name, is_primary
from
    material_names
where
    material_id = ?
`

func (q *Queries) GetMaterialNames(ctx context.Context, materialID int64) ([]MaterialName, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialNames, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MaterialName
	for rows.Next() {
		var i MaterialName
		if err := rows.Scan(
			&i.NameID,
			&i.MaterialID,
			&i.Name,
			&i.IsPrimary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialProducts = `-- name: GetMaterialProducts :many
SELECT
    p.product_id, p.name, p.description,
    pm.quantity AS quantity,
    pm.quantity_text AS quantity_text,
    ut.unit AS unit
FROM
    products p
    INNER JOIN product_materials pm ON p.product_id = pm.product_id
    INNER JOIN materials m ON m.material_id = pm.material_id
    INNER JOIN unit_types ut ON ut.unit_id = m.unit_id
WHERE
    pm.material_id = ?
`

type GetMaterialProductsRow struct {
	ProductID    int64
	Name         string
	Description  sql.NullString
	Quantity     interface{}
	QuantityText sql.NullString
	Unit         string
}

func (q *Queries) GetMaterialProducts(ctx context.Context, materialID sql.NullInt64) ([]GetMaterialProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialProducts, materialID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMaterialProductsRow
	for rows.Next() {
		var i GetMaterialProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Quantity,
			&i.QuantityText,
			&i.Unit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMaterial = `-- name: InsertMaterial :one
INSERT INTO
    materials (unit_id, description)
VALUES
    (
        (
            SELECT
                unit_id
            FROM
                unit_types
            WHERE
                unit_types.unit = ?
        ),
        ?
    ) RETURNING material_id, unit_id, description
`

type InsertMaterialParams struct {
	Unit        string
	Description sql.NullString
}

func (q *Queries) InsertMaterial(ctx context.Context, arg InsertMaterialParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, insertMaterial, arg.Unit, arg.Description)
	var i Material
	err := row.Scan(&i.MaterialID, &i.UnitID, &i.Description)
	return i, err
}

const insertMaterialName = `-- name: InsertMaterialName :one
INSERT INTO
    material_names (material_id, name, is_primary)
VALUES
    (?, ?, ?) RETURNING name_id, material_id, name, is_primary
`

type InsertMaterialNameParams struct {
	MaterialID int64
	Name       string
	IsPrimary  bool
}

func (q *Queries) InsertMaterialName(ctx context.Context, arg InsertMaterialNameParams) (MaterialName, error) {
	row := q.db.QueryRowContext(ctx, insertMaterialName, arg.MaterialID, arg.Name, arg.IsPrimary)
	var i MaterialName
	err := row.Scan(
		&i.NameID,
		&i.MaterialID,
		&i.Name,
		&i.IsPrimary,
	)
	return i, err
}

const setMaterialPrimaryName = `-- name: SetMaterialPrimaryName :exec
UPDATE material_names
SET
    is_primary = TRUE
WHERE
    name = ?
`

func (q *Queries) SetMaterialPrimaryName(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, setMaterialPrimaryName, name)
	return err
}

const unsetMaterialPrimaryName = `-- name: UnsetMaterialPrimaryName :exec
UPDATE material_names
SET
    is_primary = FALSE
WHERE
    is_primary = TRUE
    AND material_id = ?
`

func (q *Queries) UnsetMaterialPrimaryName(ctx context.Context, materialID int64) error {
	_, err := q.db.ExecContext(ctx, unsetMaterialPrimaryName, materialID)
	return err
}

const updateMaterialDescription = `-- name: UpdateMaterialDescription :one
UPDATE materials
SET
    description = ?
WHERE
    material_id = ? RETURNING material_id, unit_id, description
`

type UpdateMaterialDescriptionParams struct {
	Description sql.NullString
	MaterialID  int64
}

func (q *Queries) UpdateMaterialDescription(ctx context.Context, arg UpdateMaterialDescriptionParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, updateMaterialDescription, arg.Description, arg.MaterialID)
	var i Material
	err := row.Scan(&i.MaterialID, &i.UnitID, &i.Description)
	return i, err
}

const updateMaterialPrimaryName = `-- name: UpdateMaterialPrimaryName :one
UPDATE material_names
SET
    name = ?
WHERE
    material_id = ? RETURNING name_id, material_id, name, is_primary
`

type UpdateMaterialPrimaryNameParams struct {
	Name       string
	MaterialID int64
}

func (q *Queries) UpdateMaterialPrimaryName(ctx context.Context, arg UpdateMaterialPrimaryNameParams) (MaterialName, error) {
	row := q.db.QueryRowContext(ctx, updateMaterialPrimaryName, arg.Name, arg.MaterialID)
	var i MaterialName
	err := row.Scan(
		&i.NameID,
		&i.MaterialID,
		&i.Name,
		&i.IsPrimary,
	)
	return i, err
}

const updateMaterialUnit = `-- name: UpdateMaterialUnit :one
UPDATE materials
SET
    unit = (
        SELECT
            unit_id
        FROM
            unit_types
        WHERE
            unit_types.unit = ?
    )
WHERE
    material_id = ? RETURNING material_id, unit_id, description
`

type UpdateMaterialUnitParams struct {
	Unit       string
	MaterialID int64
}

func (q *Queries) UpdateMaterialUnit(ctx context.Context, arg UpdateMaterialUnitParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, updateMaterialUnit, arg.Unit, arg.MaterialID)
	var i Material
	err := row.Scan(&i.MaterialID, &i.UnitID, &i.Description)
	return i, err
}
